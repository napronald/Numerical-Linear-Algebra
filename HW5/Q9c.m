clear all; clc;

format long
% Formulation of A,b using x,f(x)
f = @(x) cos(4*x);
x = linspace(0,1,50);
y = f(x);

A = ones(length(x),12);
b = y';

for j=1:11
    A(:,j+1) = A(:,j).*x';
end
A
%% i) Normal equations 
clc;

% Using Cholesky + Forward + Backward to solve for coefficents
M = A'*A;
y = A'*b;

eig_values = eig(M);

R_t = nap.cholesky(M);
R = transpose(R_t);
[z] = nap.forward_sub(R_t,y);
[coe] = nap.back_sub(R,z)

res = b - A*coe
normal_res = norm(res,2)

norm_cond_num = cond(M)

%% ii) QR factorization generated by classical Gram-Schmidt
clc;

[Q, R] = nap.gram_schmidt(A); % A=QR
c = Q'*b; % c = Q'*b
[coe] = nap.back_sub(R,c) % Rx=c

res = b - A*coe
cgs_res = norm(res,2)

cgs_cond_num = cond(R)

%% iii) QR factorization generated by modified Gram-Schmidt
clc;

[Q, R] = nap.modified_gram_schmidt(A);
c = Q'*b; % c = Q'*b
[coe] = nap.back_sub(R,c) % Rx=c

res = b - A*coe
mgs_res = norm(res,2)

mgs_cond_num = cond(R)

%% iv) QR factorization generated by Householder reflectors
clc;

[Q,R] = nap.house_holder(A);
c = Q'*b; % c = Q'*b
[coe] = nap.back_sub(R,c) % Rx=c

res = b - A*coe
hou_res = norm(res,2)

hou_cond_num = cond(R)


%% v) Matlab's least squares solver
clc;

coe = A \ b

res = b - A*coe
mat_res = norm(res,2)

mat_cond_num = cond(A)

%% Table of each Method
clc;

Method = ["Normal equations"; "Classical Gram-Schmidt"; "Modified Gram-Schmidt"; "Householder"];
Norm_Residual = [normal_res; cgs_res; mgs_res; hou_res];
Condition_Number = [norm_cond_num; cgs_cond_num; mgs_cond_num; hou_cond_num];
Predicted_Rel_Err = 1e-16*[norm_cond_num; cgs_cond_num; mgs_cond_num; hou_cond_num];

T = table(Method,Norm_Residual,Condition_Number,Predicted_Rel_Err)